# How to Create a Sequelize Model with TypeScript

A complete reference guide — every line explained with theory, so you never forget.

---

## What is a Model?

A **Model** is a TypeScript class that represents a table in your database. It tells Sequelize:
- What the table is called
- What columns it has
- What data types those columns accept
- Any rules like `allowNull`, `primaryKey`, etc.

Think of it as a **blueprint of your table in code**.

---

## Step 1 — Create the Sequelize Instance

Before creating any model, you need a **Sequelize instance** — this is the actual database connection that every model will use.

Create this file inside `src/db/models/`:

```
src/db/models/sequelize.ts
```

```ts
import { Sequelize } from "sequelize";
import { db_config } from "../../config/index.ts";

const sequelize = new Sequelize({
  dialect: "mysql",
  host:     db_config.DB_HOST,
  port:     db_config.DB_PORT,
  username: db_config.DB_USER,
  password: db_config.DB_PASSWORD,
  database: db_config.DB_NAME,
});

export default sequelize;
```

### What is this file doing?

| Option | Meaning |
|---|---|
| `new Sequelize({...})` | Creates a connection to your database |
| `dialect` | Which database you are using — `"mysql"`, `"postgres"`, `"sqlite"` etc. |
| `host` | Where the database is running — usually `localhost` in dev |
| `port` | Database port — MySQL default is `3306` |
| `username` | DB user |
| `password` | DB password |
| `database` | Name of the database to connect to |

> This instance is imported in every model file via `import sequelize from './sequelize.ts'` and passed into `Model.init()`. Think of it as the **shared database connection** that all models use.

---

## Step 2 — Create the Model File

Create a new file inside `src/db/models/`. Name it after your table in singular form.

```
src/db/models/
├── sequelize.ts       # DB connection instance — create this first
├── hotel.model.ts     # Hotel model
└── ...                # other models
```

---

## Step 3 — Imports

```ts
import sequelize from './sequelize.ts';
import {
  Model,
  type CreationOptional,
  type InferAttributes,
  type InferCreationAttributes,
} from 'sequelize';
```

| Import | What it does |
|---|---|
| `Model` | Base class from Sequelize — your class extends this |
| `CreationOptional<T>` | Marks a field as optional when **creating** a record (e.g. `id`, `createdAt` — DB generates these automatically) |
| `InferAttributes<T>` | Tells Sequelize what fields exist on the model when **reading** data |
| `InferCreationAttributes<T>` | Tells Sequelize what fields are needed when **creating** a new record |
| `sequelize` | Your database connection instance |

---

## Step 4 — Define the Class

```ts
class Hotel extends Model<InferAttributes<Hotel>, InferCreationAttributes<Hotel>> {
  declare id: CreationOptional<number>;
  declare name: string;
  declare location: string;
  declare ratings: number | null;
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;
}
```

### Why `extends Model<...>`?

`Model` is Sequelize's base class. By extending it, your `Hotel` class gets all Sequelize methods like `.findAll()`, `.create()`, `.update()`, `.destroy()` etc.

The two generics tell Sequelize the shape of your data:
- First generic `InferAttributes<Hotel>` → shape when **reading**
- Second generic `InferCreationAttributes<Hotel>` → shape when **creating**

### Why `declare`?

`declare` tells TypeScript "this field exists at runtime but I'm not assigning it here in the class body." Sequelize adds these fields dynamically — `declare` just gives TypeScript the type information without emitting any JS code.

### Why `CreationOptional<T>`?

Fields like `id`, `createdAt`, `updatedAt` are auto-generated by the database — you don't need to pass them when creating a record. `CreationOptional<T>` marks them as optional during creation but required when reading.

```ts
// Without CreationOptional — TypeScript would force you to pass id manually:
Hotel.create({ id: 1, name: '...', ... }) // ❌ annoying

// With CreationOptional — id is optional:
Hotel.create({ name: '...', ... }) // ✅ clean
```

### Why `number | null` for ratings?

This means the field can either be a number or `null` — i.e. it's optional data. Maps to `allowNull: true` in the DB.

---

## Step 5 — Initialize the Model with `Hotel.init()`

```ts
Hotel.init(
  {
    // column definitions
  },
  {
    // model options
  }
);
```

`Hotel.init()` takes two arguments:
1. **Column definitions** — what columns exist and their rules
2. **Model options** — table name, sequelize instance, timestamps, etc.

---

### Column Definitions

```ts
id: {
  type: 'INTEGER',
  autoIncrement: true,
  primaryKey: true,
  allowNull: false,
},
```

| Option | Meaning |
|---|---|
| `type` | Data type of the column — `'INTEGER'`, `'STRING'`, `'DATE'`, `'BOOLEAN'`, `'FLOAT'` etc. |
| `autoIncrement` | DB automatically increases this value for each new row |
| `primaryKey` | This column is the unique identifier for each row |
| `allowNull` | Whether the column can be empty (`true`) or must have a value (`false`) |

```ts
name: {
  type: 'STRING',
  allowNull: false,
},
location: {
  type: 'STRING',
  allowNull: false,
},
ratings: {
  type: 'FLOAT',       // use FLOAT for decimal numbers like 4.5
  allowNull: true,     // ratings can be empty
},
createdAt: {
  type: 'DATE',
},
updatedAt: {
  type: 'DATE',
},
```

---

### Model Options

```ts
{
  tableName: 'Hotels',
  sequelize: sequelize,
  underscored: false,
  timestamps: true,
}
```

| Option | Meaning |
|---|---|
| `tableName` | Exact name of the table in the database — must match your migration |
| `sequelize` | The database connection instance to use |
| `timestamps` | If `true`, Sequelize auto-manages `createdAt` and `updatedAt` columns |
| `underscored` | If `true`, Sequelize uses `snake_case` column names (`created_at`). If `false`, uses `camelCase` (`createdAt`). **Keep this `false` unless your DB columns are snake_case** |

> ⚠️ `underscored` and your migration column names **must match**. If migration has `createdAt` → set `underscored: false`. If migration has `created_at` → set `underscored: true`.

---

## Step 6 — Export the Model

```ts
export default Hotel;
```

So you can import it anywhere in your app and use it to query the database.

---

## Complete Model File (Step 7 — Final Result)

```ts
import sequelize from './sequelize.ts';
import {
  Model,
  type CreationOptional,
  type InferAttributes,
  type InferCreationAttributes,
} from 'sequelize';

class Hotel extends Model<InferAttributes<Hotel>, InferCreationAttributes<Hotel>> {
  declare id: CreationOptional<number>;
  declare name: string;
  declare location: string;
  declare ratings: number | null;
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;
}

Hotel.init(
  {
    id: {
      type: 'INTEGER',
      autoIncrement: true,
      primaryKey: true,
      allowNull: false,
    },
    name: {
      type: 'STRING',
      allowNull: false,
    },
    location: {
      type: 'STRING',
      allowNull: false,
    },
    ratings: {
      type: 'FLOAT',
      allowNull: true,
    },
    createdAt: {
      type: 'DATE',
    },
    updatedAt: {
      type: 'DATE',
    },
  },
  {
    tableName: 'Hotels',
    sequelize: sequelize,
    underscored: false,
    timestamps: true,
  }
);

export default Hotel;
```

---

## Step 8 — Using the Model

Once the model is created, you can use it anywhere:

```ts
import Hotel from '../db/models/hotel.model.ts';

// Create a new record
const hotel = await Hotel.create({
  name: 'Hotel California',
  location: 'California',
  ratings: 4.5,
});

// Find all records
const hotels = await Hotel.findAll();

// Find one by id
const hotel = await Hotel.findByPk(1);

// Update a record
await Hotel.update({ ratings: 5 }, { where: { id: 1 } });

// Delete a record
await Hotel.destroy({ where: { id: 1 } });
```

---

## Common Data Types

| Sequelize Type | DB Type | Use for |
|---|---|---|
| `'INTEGER'` | INT | Whole numbers |
| `'FLOAT'` | FLOAT | Decimal numbers (ratings, price) |
| `'STRING'` | VARCHAR(255) | Short text |
| `'TEXT'` | TEXT | Long text |
| `'BOOLEAN'` | TINYINT(1) | true/false |
| `'DATE'` | DATETIME | Timestamps |
| `'DATEONLY'` | DATE | Date without time |
| `'UUID'` | CHAR(36) | UUID strings |

---

## Model vs Migration — What's the Difference?

| | Migration | Model |
|---|---|---|
| **Purpose** | Creates/modifies the actual table in DB | Represents the table in your code |
| **When it runs** | `npm run migrate` — one time | Every time your app runs |
| **Format** | `.ts` with `module.exports` | Normal TypeScript class |
| **Think of it as** | The SQL `CREATE TABLE` command | The TypeScript interface for that table |

> Both must stay in sync — if you add a column in migration, add it in the model too.

---

## Things to Remember

- Always match `underscored` option with your migration column names
- `CreationOptional` → fields the DB generates automatically (`id`, `createdAt`, `updatedAt`)
- `allowNull: true` in model + `number | null` in TypeScript always go together
- Never skip the `tableName` option — otherwise Sequelize will pluralize/guess the name
- Migration runs once to create the table — Model is used every time to interact with it